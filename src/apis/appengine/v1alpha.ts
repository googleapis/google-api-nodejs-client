/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {AxiosPromise} from 'axios';
import {Compute, JWT, OAuth2Client, UserRefreshClient} from 'google-auth-library';

import {BodyResponseCallback, createAPIRequest, GlobalOptions, GoogleConfigurable, MethodOptions} from '../../shared/src';

// tslint:disable: no-any
// tslint:disable: class-name
// tslint:disable: variable-name
// tslint:disable: jsdoc-format
// tslint:disable: no-namespace

export namespace appengine_v1alpha {
  export interface Options extends GlobalOptions {
    version: 'v1alpha';
  }

  /**
   * App Engine Admin API
   *
   * The App Engine Admin API enables developers to provision and manage their
   * App Engine applications.
   *
   * @example
   * const {google} = require('googleapis');
   * const appengine = google.appengine('v1alpha');
   *
   * @namespace appengine
   * @type {Function}
   * @version v1alpha
   * @variation v1alpha
   * @param {object=} options Options for Appengine
   */
  export class Appengine {
    _options: GlobalOptions;
    google?: GoogleConfigurable;
    root = this;

    apps: Resource$Apps;

    constructor(options: GlobalOptions, google?: GoogleConfigurable) {
      this._options = options || {};
      this.google = google;
      this.getRoot.bind(this);

      this.apps = new Resource$Apps(this);
    }

    getRoot() {
      return this.root;
    }
  }

  /**
   * An SSL certificate that a user has been authorized to administer. A user is
   * authorized to administer any certificate that applies to one of their
   * authorized domains.
   */
  export interface Schema$AuthorizedCertificate {
    /**
     * The SSL certificate serving the AuthorizedCertificate resource. This must
     * be obtained independently from a certificate authority.
     */
    certificateRawData?: Schema$CertificateRawData;
    /**
     * The user-specified display name of the certificate. This is not
     * guaranteed to be unique. Example: My Certificate.
     */
    displayName?: string;
    /**
     * Aggregate count of the domain mappings with this certificate mapped. This
     * count includes domain mappings on applications for which the user does
     * not have VIEWER permissions.Only returned by GET or LIST requests when
     * specifically requested by the view=FULL_CERTIFICATE option.@OutputOnly
     */
    domainMappingsCount?: number;
    /**
     * Topmost applicable domains of this certificate. This certificate applies
     * to these domains and their subdomains. Example: example.com.@OutputOnly
     */
    domainNames?: string[];
    /**
     * The time when this certificate expires. To update the renewal time on
     * this certificate, upload an SSL certificate with a different expiration
     * time using AuthorizedCertificates.UpdateAuthorizedCertificate.@OutputOnly
     */
    expireTime?: string;
    /**
     * Relative name of the certificate. This is a unique value autogenerated on
     * AuthorizedCertificate resource creation. Example: 12345.@OutputOnly
     */
    id?: string;
    /**
     * Only applicable if this certificate is managed by App Engine. Managed
     * certificates are tied to the lifecycle of a DomainMapping and cannot be
     * updated or deleted via the AuthorizedCertificates API. If this
     * certificate is manually administered by the user, this field will be
     * empty.@OutputOnly
     */
    managedCertificate?: Schema$ManagedCertificate;
    /**
     * Full path to the AuthorizedCertificate resource in the API. Example:
     * apps/myapp/authorizedCertificates/12345.@OutputOnly
     */
    name?: string;
    /**
     * The full paths to user visible Domain Mapping resources that have this
     * certificate mapped. Example: apps/myapp/domainMappings/example.com.This
     * may not represent the full list of mapped domain mappings if the user
     * does not have VIEWER permissions on all of the applications that have
     * this certificate mapped. See domain_mappings_count for a complete
     * count.Only returned by GET or LIST requests when specifically requested
     * by the view=FULL_CERTIFICATE option.@OutputOnly
     */
    visibleDomainMappings?: string[];
  }
  /**
   * A domain that a user has been authorized to administer. To authorize use of
   * a domain, verify ownership via Webmaster Central
   * (https://www.google.com/webmasters/verification/home).
   */
  export interface Schema$AuthorizedDomain {
    /**
     * Fully qualified domain name of the domain authorized for use. Example:
     * example.com.
     */
    id?: string;
    /**
     * Full path to the AuthorizedDomain resource in the API. Example:
     * apps/myapp/authorizedDomains/example.com.@OutputOnly
     */
    name?: string;
  }
  /**
   * An SSL certificate obtained from a certificate authority.
   */
  export interface Schema$CertificateRawData {
    /**
     * Unencrypted PEM encoded RSA private key. This field is set once on
     * certificate creation and then encrypted. The key size must be 2048 bits
     * or fewer. Must include the header and footer. Example: &lt;pre&gt;
     * -----BEGIN RSA PRIVATE KEY----- &lt;unencrypted_key_value&gt; -----END
     * RSA PRIVATE KEY----- &lt;/pre&gt; @InputOnly
     */
    privateKey?: string;
    /**
     * PEM encoded x.509 public key certificate. This field is set once on
     * certificate creation. Must include the header and footer. Example:
     * &lt;pre&gt; -----BEGIN CERTIFICATE----- &lt;certificate_value&gt;
     * -----END CERTIFICATE----- &lt;/pre&gt;
     */
    publicCertificate?: string;
  }
  /**
   * Metadata for the given google.longrunning.Operation during a
   * google.appengine.v1.CreateVersionRequest.
   */
  export interface Schema$CreateVersionMetadataV1 {
    /**
     * The Cloud Build ID if one was created as part of the version create.
     * @OutputOnly
     */
    cloudBuildId?: string;
  }
  /**
   * Metadata for the given google.longrunning.Operation during a
   * google.appengine.v1alpha.CreateVersionRequest.
   */
  export interface Schema$CreateVersionMetadataV1Alpha {
    /**
     * The Cloud Build ID if one was created as part of the version create.
     * @OutputOnly
     */
    cloudBuildId?: string;
  }
  /**
   * Metadata for the given google.longrunning.Operation during a
   * google.appengine.v1beta.CreateVersionRequest.
   */
  export interface Schema$CreateVersionMetadataV1Beta {
    /**
     * The Cloud Build ID if one was created as part of the version create.
     * @OutputOnly
     */
    cloudBuildId?: string;
  }
  /**
   * A domain serving an App Engine application.
   */
  export interface Schema$DomainMapping {
    /**
     * Relative name of the domain serving the application. Example:
     * example.com.
     */
    id?: string;
    /**
     * Full path to the DomainMapping resource in the API. Example:
     * apps/myapp/domainMapping/example.com.@OutputOnly
     */
    name?: string;
    /**
     * The resource records required to configure this domain mapping. These
     * records must be added to the domain&#39;s DNS configuration in order to
     * serve the application via this domain mapping.@OutputOnly
     */
    resourceRecords?: Schema$ResourceRecord[];
    /**
     * SSL configuration for this domain. If unconfigured, this domain will not
     * serve with SSL.
     */
    sslSettings?: Schema$SslSettings;
  }
  /**
   * A generic empty message that you can re-use to avoid defining duplicated
   * empty messages in your APIs. A typical example is to use it as the request
   * or the response type of an API method. For instance: service Foo {   rpc
   * Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON
   * representation for Empty is empty JSON object {}.
   */
  export interface Schema$Empty {}
  /**
   * Response message for AuthorizedCertificates.ListAuthorizedCertificates.
   */
  export interface Schema$ListAuthorizedCertificatesResponse {
    /**
     * The SSL certificates the user is authorized to administer.
     */
    certificates?: Schema$AuthorizedCertificate[];
    /**
     * Continuation token for fetching the next page of results.
     */
    nextPageToken?: string;
  }
  /**
   * Response message for AuthorizedDomains.ListAuthorizedDomains.
   */
  export interface Schema$ListAuthorizedDomainsResponse {
    /**
     * The authorized domains belonging to the user.
     */
    domains?: Schema$AuthorizedDomain[];
    /**
     * Continuation token for fetching the next page of results.
     */
    nextPageToken?: string;
  }
  /**
   * Response message for DomainMappings.ListDomainMappings.
   */
  export interface Schema$ListDomainMappingsResponse {
    /**
     * The domain mappings for the application.
     */
    domainMappings?: Schema$DomainMapping[];
    /**
     * Continuation token for fetching the next page of results.
     */
    nextPageToken?: string;
  }
  /**
   * The response message for Locations.ListLocations.
   */
  export interface Schema$ListLocationsResponse {
    /**
     * A list of locations that matches the specified filter in the request.
     */
    locations?: Schema$Location[];
    /**
     * The standard List next-page token.
     */
    nextPageToken?: string;
  }
  /**
   * The response message for Operations.ListOperations.
   */
  export interface Schema$ListOperationsResponse {
    /**
     * The standard List next-page token.
     */
    nextPageToken?: string;
    /**
     * A list of operations that matches the specified filter in the request.
     */
    operations?: Schema$Operation[];
  }
  /**
   * A resource that represents Google Cloud Platform location.
   */
  export interface Schema$Location {
    /**
     * The friendly name for this location, typically a nearby city name. For
     * example, &quot;Tokyo&quot;.
     */
    displayName?: string;
    /**
     * Cross-service attributes for the location. For example
     * {&quot;cloud.googleapis.com/region&quot;: &quot;us-east1&quot;}
     */
    labels?: any;
    /**
     * The canonical id for this location. For example: &quot;us-east1&quot;.
     */
    locationId?: string;
    /**
     * Service-specific metadata. For example the available capacity at the
     * given location.
     */
    metadata?: any;
    /**
     * Resource name for the location, which may vary between implementations.
     * For example: &quot;projects/example-project/locations/us-east1&quot;
     */
    name?: string;
  }
  /**
   * Metadata for the given google.cloud.location.Location.
   */
  export interface Schema$LocationMetadata {
    /**
     * App Engine flexible environment is available in the given
     * location.@OutputOnly
     */
    flexibleEnvironmentAvailable?: boolean;
    /**
     * App Engine standard environment is available in the given
     * location.@OutputOnly
     */
    standardEnvironmentAvailable?: boolean;
  }
  /**
   * A certificate managed by App Engine.
   */
  export interface Schema$ManagedCertificate {
    /**
     * Time at which the certificate was last renewed. The renewal process is
     * fully managed. Certificate renewal will automatically occur before the
     * certificate expires. Renewal errors can be tracked via
     * ManagementStatus.@OutputOnly
     */
    lastRenewalTime?: string;
    /**
     * Status of certificate management. Refers to the most recent certificate
     * acquisition or renewal attempt.@OutputOnly
     */
    status?: string;
  }
  /**
   * This resource represents a long-running operation that is the result of a
   * network API call.
   */
  export interface Schema$Operation {
    /**
     * If the value is false, it means the operation is still in progress. If
     * true, the operation is completed, and either error or response is
     * available.
     */
    done?: boolean;
    /**
     * The error result of the operation in case of failure or cancellation.
     */
    error?: Schema$Status;
    /**
     * Service-specific metadata associated with the operation. It typically
     * contains progress information and common metadata such as create time.
     * Some services might not provide such metadata. Any method that returns a
     * long-running operation should document the metadata type, if any.
     */
    metadata?: any;
    /**
     * The server-assigned name, which is only unique within the same service
     * that originally returns it. If you use the default HTTP mapping, the name
     * should have the format of operations/some/unique/name.
     */
    name?: string;
    /**
     * The normal response of the operation in case of success. If the original
     * method returns no data on success, such as Delete, the response is
     * google.protobuf.Empty. If the original method is standard
     * Get/Create/Update, the response should be the resource. For other
     * methods, the response should have the type XxxResponse, where Xxx is the
     * original method name. For example, if the original method name is
     * TakeSnapshot(), the inferred response type is TakeSnapshotResponse.
     */
    response?: any;
  }
  /**
   * Metadata for the given google.longrunning.Operation.
   */
  export interface Schema$OperationMetadata {
    /**
     * Timestamp that this operation completed.@OutputOnly
     */
    endTime?: string;
    /**
     * Timestamp that this operation was created.@OutputOnly
     */
    insertTime?: string;
    /**
     * API method that initiated this operation. Example:
     * google.appengine.v1beta4.Version.CreateVersion.@OutputOnly
     */
    method?: string;
    /**
     * Type of this operation. Deprecated, use method field instead. Example:
     * &quot;create_version&quot;.@OutputOnly
     */
    operationType?: string;
    /**
     * Name of the resource that this operation is acting on. Example:
     * apps/myapp/modules/default.@OutputOnly
     */
    target?: string;
    /**
     * User who requested this operation.@OutputOnly
     */
    user?: string;
  }
  /**
   * Metadata for the given google.longrunning.Operation.
   */
  export interface Schema$OperationMetadataV1 {
    createVersionMetadata?: Schema$CreateVersionMetadataV1;
    /**
     * Time that this operation completed.@OutputOnly
     */
    endTime?: string;
    /**
     * Ephemeral message that may change every time the operation is polled.
     * @OutputOnly
     */
    ephemeralMessage?: string;
    /**
     * Time that this operation was created.@OutputOnly
     */
    insertTime?: string;
    /**
     * API method that initiated this operation. Example:
     * google.appengine.v1.Versions.CreateVersion.@OutputOnly
     */
    method?: string;
    /**
     * Name of the resource that this operation is acting on. Example:
     * apps/myapp/services/default.@OutputOnly
     */
    target?: string;
    /**
     * User who requested this operation.@OutputOnly
     */
    user?: string;
    /**
     * Durable messages that persist on every operation poll. @OutputOnly
     */
    warning?: string[];
  }
  /**
   * Metadata for the given google.longrunning.Operation.
   */
  export interface Schema$OperationMetadataV1Alpha {
    createVersionMetadata?: Schema$CreateVersionMetadataV1Alpha;
    /**
     * Time that this operation completed.@OutputOnly
     */
    endTime?: string;
    /**
     * Ephemeral message that may change every time the operation is polled.
     * @OutputOnly
     */
    ephemeralMessage?: string;
    /**
     * Time that this operation was created.@OutputOnly
     */
    insertTime?: string;
    /**
     * API method that initiated this operation. Example:
     * google.appengine.v1alpha.Versions.CreateVersion.@OutputOnly
     */
    method?: string;
    /**
     * Name of the resource that this operation is acting on. Example:
     * apps/myapp/services/default.@OutputOnly
     */
    target?: string;
    /**
     * User who requested this operation.@OutputOnly
     */
    user?: string;
    /**
     * Durable messages that persist on every operation poll. @OutputOnly
     */
    warning?: string[];
  }
  /**
   * Metadata for the given google.longrunning.Operation.
   */
  export interface Schema$OperationMetadataV1Beta {
    createVersionMetadata?: Schema$CreateVersionMetadataV1Beta;
    /**
     * Time that this operation completed.@OutputOnly
     */
    endTime?: string;
    /**
     * Ephemeral message that may change every time the operation is polled.
     * @OutputOnly
     */
    ephemeralMessage?: string;
    /**
     * Time that this operation was created.@OutputOnly
     */
    insertTime?: string;
    /**
     * API method that initiated this operation. Example:
     * google.appengine.v1beta.Versions.CreateVersion.@OutputOnly
     */
    method?: string;
    /**
     * Name of the resource that this operation is acting on. Example:
     * apps/myapp/services/default.@OutputOnly
     */
    target?: string;
    /**
     * User who requested this operation.@OutputOnly
     */
    user?: string;
    /**
     * Durable messages that persist on every operation poll. @OutputOnly
     */
    warning?: string[];
  }
  /**
   * Metadata for the given google.longrunning.Operation.
   */
  export interface Schema$OperationMetadataV1Beta5 {
    /**
     * Timestamp that this operation completed.@OutputOnly
     */
    endTime?: string;
    /**
     * Timestamp that this operation was created.@OutputOnly
     */
    insertTime?: string;
    /**
     * API method name that initiated this operation. Example:
     * google.appengine.v1beta5.Version.CreateVersion.@OutputOnly
     */
    method?: string;
    /**
     * Name of the resource that this operation is acting on. Example:
     * apps/myapp/services/default.@OutputOnly
     */
    target?: string;
    /**
     * User who requested this operation.@OutputOnly
     */
    user?: string;
  }
  /**
   * A DNS resource record.
   */
  export interface Schema$ResourceRecord {
    /**
     * Relative name of the object affected by this record. Only applicable for
     * CNAME records. Example: &#39;www&#39;.
     */
    name?: string;
    /**
     * Data for this record. Values vary by record type, as defined in RFC 1035
     * (section 5) and RFC 1034 (section 3.6.1).
     */
    rrdata?: string;
    /**
     * Resource record type. Example: AAAA.
     */
    type?: string;
  }
  /**
   * SSL configuration for a DomainMapping resource.
   */
  export interface Schema$SslSettings {
    /**
     * ID of the AuthorizedCertificate resource configuring SSL for the
     * application. Clearing this field will remove SSL support.By default, a
     * managed certificate is automatically created for every domain mapping. To
     * omit SSL support or to configure SSL manually, specify
     * no_managed_certificate on a CREATE or UPDATE request. You must be
     * authorized to administer the AuthorizedCertificate resource to manually
     * map it to a DomainMapping resource. Example: 12345.
     */
    certificateId?: string;
    /**
     * Whether the mapped certificate is an App Engine managed certificate.
     * Managed certificates are created by default with a domain mapping. To opt
     * out, specify no_managed_certificate on a CREATE or UPDATE
     * request.@OutputOnly
     */
    isManagedCertificate?: boolean;
  }
  /**
   * The Status type defines a logical error model that is suitable for
   * different programming environments, including REST APIs and RPC APIs. It is
   * used by gRPC (https://github.com/grpc). The error model is designed to be:
   * Simple to use and understand for most users Flexible enough to meet
   * unexpected needsOverviewThe Status message contains three pieces of data:
   * error code, error message, and error details. The error code should be an
   * enum value of google.rpc.Code, but it may accept additional error codes if
   * needed. The error message should be a developer-facing English message that
   * helps developers understand and resolve the error. If a localized
   * user-facing error message is needed, put the localized message in the error
   * details or localize it in the client. The optional error details may
   * contain arbitrary information about the error. There is a predefined set of
   * error detail types in the package google.rpc that can be used for common
   * error conditions.Language mappingThe Status message is the logical
   * representation of the error model, but it is not necessarily the actual
   * wire format. When the Status message is exposed in different client
   * libraries and different wire protocols, it can be mapped differently. For
   * example, it will likely be mapped to some exceptions in Java, but more
   * likely mapped to some error codes in C.Other usesThe error model and the
   * Status message can be used in a variety of environments, either with or
   * without APIs, to provide a consistent developer experience across different
   * environments.Example uses of this error model include: Partial errors. If a
   * service needs to return partial errors to the client, it may embed the
   * Status in the normal response to indicate the partial errors. Workflow
   * errors. A typical workflow has multiple steps. Each step may have a Status
   * message for error reporting. Batch operations. If a client uses batch
   * request and batch response, the Status message should be used directly
   * inside batch response, one for each error sub-response. Asynchronous
   * operations. If an API call embeds asynchronous operation results in its
   * response, the status of those operations should be represented directly
   * using the Status message. Logging. If some API errors are stored in logs,
   * the message Status could be used directly after any stripping needed for
   * security/privacy reasons.
   */
  export interface Schema$Status {
    /**
     * The status code, which should be an enum value of google.rpc.Code.
     */
    code?: number;
    /**
     * A list of messages that carry the error details. There is a common set of
     * message types for APIs to use.
     */
    details?: any[];
    /**
     * A developer-facing error message, which should be in English. Any
     * user-facing error message should be localized and sent in the
     * google.rpc.Status.details field, or localized by the client.
     */
    message?: string;
  }


  export class Resource$Apps {
    root: Appengine;
    authorizedCertificates: Resource$Apps$Authorizedcertificates;
    authorizedDomains: Resource$Apps$Authorizeddomains;
    domainMappings: Resource$Apps$Domainmappings;
    locations: Resource$Apps$Locations;
    operations: Resource$Apps$Operations;
    constructor(root: Appengine) {
      this.root = root;
      this.getRoot.bind(this);
      this.authorizedCertificates =
          new Resource$Apps$Authorizedcertificates(root);
      this.authorizedDomains = new Resource$Apps$Authorizeddomains(root);
      this.domainMappings = new Resource$Apps$Domainmappings(root);
      this.locations = new Resource$Apps$Locations(root);
      this.operations = new Resource$Apps$Operations(root);
    }

    getRoot() {
      return this.root;
    }
  }


  export class Resource$Apps$Authorizedcertificates {
    root: Appengine;
    constructor(root: Appengine) {
      this.root = root;
      this.getRoot.bind(this);
    }

    getRoot() {
      return this.root;
    }


    /**
     * appengine.apps.authorizedCertificates.create
     * @desc Uploads the specified SSL certificate.
     * @alias appengine.apps.authorizedCertificates.create
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `parent`. Name of the parent Application resource. Example: apps/myapp.
     * @param {().AuthorizedCertificate} params.resource Request body data
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    create(
        params?: Params$Resource$Apps$Authorizedcertificates$Create,
        options?: MethodOptions): AxiosPromise<Schema$AuthorizedCertificate>;
    create(
        params: Params$Resource$Apps$Authorizedcertificates$Create,
        options: MethodOptions|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    create(
        params: Params$Resource$Apps$Authorizedcertificates$Create,
        callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    create(callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    create(
        paramsOrCallback?: Params$Resource$Apps$Authorizedcertificates$Create|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        callback?: BodyResponseCallback<Schema$AuthorizedCertificate>):
        void|AxiosPromise<Schema$AuthorizedCertificate> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Authorizedcertificates$Create;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Authorizedcertificates$Create;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/authorizedCertificates')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'POST'
            },
            options),
        params,
        requiredParams: ['appsId'],
        pathParams: ['appsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$AuthorizedCertificate>(parameters, callback);
      } else {
        return createAPIRequest<Schema$AuthorizedCertificate>(parameters);
      }
    }


    /**
     * appengine.apps.authorizedCertificates.delete
     * @desc Deletes the specified SSL certificate.
     * @alias appengine.apps.authorizedCertificates.delete
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. Name of the resource to delete. Example: apps/myapp/authorizedCertificates/12345.
     * @param {string} params.authorizedCertificatesId Part of `name`. See documentation of `appsId`.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    delete(
        params?: Params$Resource$Apps$Authorizedcertificates$Delete,
        options?: MethodOptions): AxiosPromise<Schema$Empty>;
    delete(
        params: Params$Resource$Apps$Authorizedcertificates$Delete,
        options: MethodOptions|BodyResponseCallback<Schema$Empty>,
        callback: BodyResponseCallback<Schema$Empty>): void;
    delete(
        params: Params$Resource$Apps$Authorizedcertificates$Delete,
        callback: BodyResponseCallback<Schema$Empty>): void;
    delete(callback: BodyResponseCallback<Schema$Empty>): void;
    delete(
        paramsOrCallback?: Params$Resource$Apps$Authorizedcertificates$Delete|
        BodyResponseCallback<Schema$Empty>,
        optionsOrCallback?: MethodOptions|BodyResponseCallback<Schema$Empty>,
        callback?: BodyResponseCallback<Schema$Empty>):
        void|AxiosPromise<Schema$Empty> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Authorizedcertificates$Delete;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Authorizedcertificates$Delete;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url:
                  (rootUrl +
                   '/v1alpha/apps/{appsId}/authorizedCertificates/{authorizedCertificatesId}')
                      .replace(/([^:]\/)\/+/g, '$1'),
              method: 'DELETE'
            },
            options),
        params,
        requiredParams: ['appsId', 'authorizedCertificatesId'],
        pathParams: ['appsId', 'authorizedCertificatesId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$Empty>(parameters, callback);
      } else {
        return createAPIRequest<Schema$Empty>(parameters);
      }
    }


    /**
     * appengine.apps.authorizedCertificates.get
     * @desc Gets the specified SSL certificate.
     * @alias appengine.apps.authorizedCertificates.get
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. Name of the resource requested. Example: apps/myapp/authorizedCertificates/12345.
     * @param {string} params.authorizedCertificatesId Part of `name`. See documentation of `appsId`.
     * @param {string=} params.view Controls the set of fields returned in the GET response.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    get(params?: Params$Resource$Apps$Authorizedcertificates$Get,
        options?: MethodOptions): AxiosPromise<Schema$AuthorizedCertificate>;
    get(params: Params$Resource$Apps$Authorizedcertificates$Get,
        options: MethodOptions|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    get(params: Params$Resource$Apps$Authorizedcertificates$Get,
        callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    get(callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    get(paramsOrCallback?: Params$Resource$Apps$Authorizedcertificates$Get|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        callback?: BodyResponseCallback<Schema$AuthorizedCertificate>):
        void|AxiosPromise<Schema$AuthorizedCertificate> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Authorizedcertificates$Get;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Authorizedcertificates$Get;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url:
                  (rootUrl +
                   '/v1alpha/apps/{appsId}/authorizedCertificates/{authorizedCertificatesId}')
                      .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId', 'authorizedCertificatesId'],
        pathParams: ['appsId', 'authorizedCertificatesId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$AuthorizedCertificate>(parameters, callback);
      } else {
        return createAPIRequest<Schema$AuthorizedCertificate>(parameters);
      }
    }


    /**
     * appengine.apps.authorizedCertificates.list
     * @desc Lists all SSL certificates the user is authorized to administer.
     * @alias appengine.apps.authorizedCertificates.list
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `parent`. Name of the parent Application resource. Example: apps/myapp.
     * @param {integer=} params.pageSize Maximum results to return per page.
     * @param {string=} params.pageToken Continuation token for fetching the next page of results.
     * @param {string=} params.view Controls the set of fields returned in the LIST response.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    list(
        params?: Params$Resource$Apps$Authorizedcertificates$List,
        options?: MethodOptions):
        AxiosPromise<Schema$ListAuthorizedCertificatesResponse>;
    list(
        params: Params$Resource$Apps$Authorizedcertificates$List,
        options: MethodOptions|
        BodyResponseCallback<Schema$ListAuthorizedCertificatesResponse>,
        callback:
            BodyResponseCallback<Schema$ListAuthorizedCertificatesResponse>):
        void;
    list(
        params: Params$Resource$Apps$Authorizedcertificates$List,
        callback:
            BodyResponseCallback<Schema$ListAuthorizedCertificatesResponse>):
        void;
    list(callback:
             BodyResponseCallback<Schema$ListAuthorizedCertificatesResponse>):
        void;
    list(
        paramsOrCallback?: Params$Resource$Apps$Authorizedcertificates$List|
        BodyResponseCallback<Schema$ListAuthorizedCertificatesResponse>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$ListAuthorizedCertificatesResponse>,
        callback?:
            BodyResponseCallback<Schema$ListAuthorizedCertificatesResponse>):
        void|AxiosPromise<Schema$ListAuthorizedCertificatesResponse> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Authorizedcertificates$List;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Authorizedcertificates$List;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/authorizedCertificates')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId'],
        pathParams: ['appsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$ListAuthorizedCertificatesResponse>(
            parameters, callback);
      } else {
        return createAPIRequest<Schema$ListAuthorizedCertificatesResponse>(
            parameters);
      }
    }


    /**
     * appengine.apps.authorizedCertificates.patch
     * @desc Updates the specified SSL certificate. To renew a certificate and
     * maintain its existing domain mappings, update certificate_data with a new
     * certificate. The new certificate must be applicable to the same domains
     * as the original certificate. The certificate display_name may also be
     * updated.
     * @alias appengine.apps.authorizedCertificates.patch
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. Name of the resource to update. Example: apps/myapp/authorizedCertificates/12345.
     * @param {string} params.authorizedCertificatesId Part of `name`. See documentation of `appsId`.
     * @param {string=} params.updateMask Standard field mask for the set of fields to be updated. Updates are only supported on the certificate_raw_data and display_name fields.
     * @param {().AuthorizedCertificate} params.resource Request body data
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    patch(
        params?: Params$Resource$Apps$Authorizedcertificates$Patch,
        options?: MethodOptions): AxiosPromise<Schema$AuthorizedCertificate>;
    patch(
        params: Params$Resource$Apps$Authorizedcertificates$Patch,
        options: MethodOptions|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    patch(
        params: Params$Resource$Apps$Authorizedcertificates$Patch,
        callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    patch(callback: BodyResponseCallback<Schema$AuthorizedCertificate>): void;
    patch(
        paramsOrCallback?: Params$Resource$Apps$Authorizedcertificates$Patch|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$AuthorizedCertificate>,
        callback?: BodyResponseCallback<Schema$AuthorizedCertificate>):
        void|AxiosPromise<Schema$AuthorizedCertificate> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Authorizedcertificates$Patch;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Authorizedcertificates$Patch;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url:
                  (rootUrl +
                   '/v1alpha/apps/{appsId}/authorizedCertificates/{authorizedCertificatesId}')
                      .replace(/([^:]\/)\/+/g, '$1'),
              method: 'PATCH'
            },
            options),
        params,
        requiredParams: ['appsId', 'authorizedCertificatesId'],
        pathParams: ['appsId', 'authorizedCertificatesId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$AuthorizedCertificate>(parameters, callback);
      } else {
        return createAPIRequest<Schema$AuthorizedCertificate>(parameters);
      }
    }
  }

  export interface Params$Resource$Apps$Authorizedcertificates$Create {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `parent`. Name of the parent Application resource. Example:
     * apps/myapp.
     */
    appsId?: string;

    /**
     * Request body metadata
     */
    requestBody?: Schema$AuthorizedCertificate;
  }
  export interface Params$Resource$Apps$Authorizedcertificates$Delete {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. Name of the resource to delete. Example:
     * apps/myapp/authorizedCertificates/12345.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    authorizedCertificatesId?: string;
  }
  export interface Params$Resource$Apps$Authorizedcertificates$Get {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. Name of the resource requested. Example:
     * apps/myapp/authorizedCertificates/12345.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    authorizedCertificatesId?: string;
    /**
     * Controls the set of fields returned in the GET response.
     */
    view?: string;
  }
  export interface Params$Resource$Apps$Authorizedcertificates$List {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `parent`. Name of the parent Application resource. Example:
     * apps/myapp.
     */
    appsId?: string;
    /**
     * Maximum results to return per page.
     */
    pageSize?: number;
    /**
     * Continuation token for fetching the next page of results.
     */
    pageToken?: string;
    /**
     * Controls the set of fields returned in the LIST response.
     */
    view?: string;
  }
  export interface Params$Resource$Apps$Authorizedcertificates$Patch {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. Name of the resource to update. Example:
     * apps/myapp/authorizedCertificates/12345.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    authorizedCertificatesId?: string;
    /**
     * Standard field mask for the set of fields to be updated. Updates are only
     * supported on the certificate_raw_data and display_name fields.
     */
    updateMask?: string;

    /**
     * Request body metadata
     */
    requestBody?: Schema$AuthorizedCertificate;
  }


  export class Resource$Apps$Authorizeddomains {
    root: Appengine;
    constructor(root: Appengine) {
      this.root = root;
      this.getRoot.bind(this);
    }

    getRoot() {
      return this.root;
    }


    /**
     * appengine.apps.authorizedDomains.list
     * @desc Lists all domains the user is authorized to administer.
     * @alias appengine.apps.authorizedDomains.list
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `parent`. Name of the parent Application resource. Example: apps/myapp.
     * @param {integer=} params.pageSize Maximum results to return per page.
     * @param {string=} params.pageToken Continuation token for fetching the next page of results.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    list(
        params?: Params$Resource$Apps$Authorizeddomains$List,
        options?: MethodOptions):
        AxiosPromise<Schema$ListAuthorizedDomainsResponse>;
    list(
        params: Params$Resource$Apps$Authorizeddomains$List,
        options: MethodOptions|
        BodyResponseCallback<Schema$ListAuthorizedDomainsResponse>,
        callback: BodyResponseCallback<Schema$ListAuthorizedDomainsResponse>):
        void;
    list(
        params: Params$Resource$Apps$Authorizeddomains$List,
        callback: BodyResponseCallback<Schema$ListAuthorizedDomainsResponse>):
        void;
    list(callback: BodyResponseCallback<Schema$ListAuthorizedDomainsResponse>):
        void;
    list(
        paramsOrCallback?: Params$Resource$Apps$Authorizeddomains$List|
        BodyResponseCallback<Schema$ListAuthorizedDomainsResponse>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$ListAuthorizedDomainsResponse>,
        callback?: BodyResponseCallback<Schema$ListAuthorizedDomainsResponse>):
        void|AxiosPromise<Schema$ListAuthorizedDomainsResponse> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Authorizeddomains$List;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Authorizeddomains$List;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/authorizedDomains')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId'],
        pathParams: ['appsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$ListAuthorizedDomainsResponse>(
            parameters, callback);
      } else {
        return createAPIRequest<Schema$ListAuthorizedDomainsResponse>(
            parameters);
      }
    }
  }

  export interface Params$Resource$Apps$Authorizeddomains$List {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `parent`. Name of the parent Application resource. Example:
     * apps/myapp.
     */
    appsId?: string;
    /**
     * Maximum results to return per page.
     */
    pageSize?: number;
    /**
     * Continuation token for fetching the next page of results.
     */
    pageToken?: string;
  }


  export class Resource$Apps$Domainmappings {
    root: Appengine;
    constructor(root: Appengine) {
      this.root = root;
      this.getRoot.bind(this);
    }

    getRoot() {
      return this.root;
    }


    /**
     * appengine.apps.domainMappings.create
     * @desc Maps a domain to an application. A user must be authorized to
     * administer a domain in order to map it to an application. For a list of
     * available authorized domains, see
     * AuthorizedDomains.ListAuthorizedDomains.
     * @alias appengine.apps.domainMappings.create
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `parent`. Name of the parent Application resource. Example: apps/myapp.
     * @param {boolean=} params.noManagedCertificate Whether a managed certificate should be provided by App Engine. If true, a certificate ID must be manaually set in the DomainMapping resource to configure SSL for this domain. If false, a managed certificate will be provisioned and a certificate ID will be automatically populated.
     * @param {string=} params.overrideStrategy Whether the domain creation should override any existing mappings for this domain. By default, overrides are rejected.
     * @param {().DomainMapping} params.resource Request body data
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    create(
        params?: Params$Resource$Apps$Domainmappings$Create,
        options?: MethodOptions): AxiosPromise<Schema$Operation>;
    create(
        params: Params$Resource$Apps$Domainmappings$Create,
        options: MethodOptions|BodyResponseCallback<Schema$Operation>,
        callback: BodyResponseCallback<Schema$Operation>): void;
    create(
        params: Params$Resource$Apps$Domainmappings$Create,
        callback: BodyResponseCallback<Schema$Operation>): void;
    create(callback: BodyResponseCallback<Schema$Operation>): void;
    create(
        paramsOrCallback?: Params$Resource$Apps$Domainmappings$Create|
        BodyResponseCallback<Schema$Operation>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$Operation>,
        callback?: BodyResponseCallback<Schema$Operation>):
        void|AxiosPromise<Schema$Operation> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Domainmappings$Create;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Domainmappings$Create;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/domainMappings')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'POST'
            },
            options),
        params,
        requiredParams: ['appsId'],
        pathParams: ['appsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$Operation>(parameters, callback);
      } else {
        return createAPIRequest<Schema$Operation>(parameters);
      }
    }


    /**
     * appengine.apps.domainMappings.delete
     * @desc Deletes the specified domain mapping. A user must be authorized to
     * administer the associated domain in order to delete a DomainMapping
     * resource.
     * @alias appengine.apps.domainMappings.delete
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. Name of the resource to delete. Example: apps/myapp/domainMappings/example.com.
     * @param {string} params.domainMappingsId Part of `name`. See documentation of `appsId`.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    delete(
        params?: Params$Resource$Apps$Domainmappings$Delete,
        options?: MethodOptions): AxiosPromise<Schema$Operation>;
    delete(
        params: Params$Resource$Apps$Domainmappings$Delete,
        options: MethodOptions|BodyResponseCallback<Schema$Operation>,
        callback: BodyResponseCallback<Schema$Operation>): void;
    delete(
        params: Params$Resource$Apps$Domainmappings$Delete,
        callback: BodyResponseCallback<Schema$Operation>): void;
    delete(callback: BodyResponseCallback<Schema$Operation>): void;
    delete(
        paramsOrCallback?: Params$Resource$Apps$Domainmappings$Delete|
        BodyResponseCallback<Schema$Operation>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$Operation>,
        callback?: BodyResponseCallback<Schema$Operation>):
        void|AxiosPromise<Schema$Operation> {
      let params = (paramsOrCallback || {}) as
          Params$Resource$Apps$Domainmappings$Delete;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Domainmappings$Delete;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl +
                    '/v1alpha/apps/{appsId}/domainMappings/{domainMappingsId}')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'DELETE'
            },
            options),
        params,
        requiredParams: ['appsId', 'domainMappingsId'],
        pathParams: ['appsId', 'domainMappingsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$Operation>(parameters, callback);
      } else {
        return createAPIRequest<Schema$Operation>(parameters);
      }
    }


    /**
     * appengine.apps.domainMappings.get
     * @desc Gets the specified domain mapping.
     * @alias appengine.apps.domainMappings.get
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. Name of the resource requested. Example: apps/myapp/domainMappings/example.com.
     * @param {string} params.domainMappingsId Part of `name`. See documentation of `appsId`.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    get(params?: Params$Resource$Apps$Domainmappings$Get,
        options?: MethodOptions): AxiosPromise<Schema$DomainMapping>;
    get(params: Params$Resource$Apps$Domainmappings$Get,
        options: MethodOptions|BodyResponseCallback<Schema$DomainMapping>,
        callback: BodyResponseCallback<Schema$DomainMapping>): void;
    get(params: Params$Resource$Apps$Domainmappings$Get,
        callback: BodyResponseCallback<Schema$DomainMapping>): void;
    get(callback: BodyResponseCallback<Schema$DomainMapping>): void;
    get(paramsOrCallback?: Params$Resource$Apps$Domainmappings$Get|
        BodyResponseCallback<Schema$DomainMapping>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$DomainMapping>,
        callback?: BodyResponseCallback<Schema$DomainMapping>):
        void|AxiosPromise<Schema$DomainMapping> {
      let params =
          (paramsOrCallback || {}) as Params$Resource$Apps$Domainmappings$Get;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Domainmappings$Get;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl +
                    '/v1alpha/apps/{appsId}/domainMappings/{domainMappingsId}')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId', 'domainMappingsId'],
        pathParams: ['appsId', 'domainMappingsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$DomainMapping>(parameters, callback);
      } else {
        return createAPIRequest<Schema$DomainMapping>(parameters);
      }
    }


    /**
     * appengine.apps.domainMappings.list
     * @desc Lists the domain mappings on an application.
     * @alias appengine.apps.domainMappings.list
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `parent`. Name of the parent Application resource. Example: apps/myapp.
     * @param {integer=} params.pageSize Maximum results to return per page.
     * @param {string=} params.pageToken Continuation token for fetching the next page of results.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    list(
        params?: Params$Resource$Apps$Domainmappings$List,
        options?: MethodOptions):
        AxiosPromise<Schema$ListDomainMappingsResponse>;
    list(
        params: Params$Resource$Apps$Domainmappings$List,
        options: MethodOptions|
        BodyResponseCallback<Schema$ListDomainMappingsResponse>,
        callback: BodyResponseCallback<Schema$ListDomainMappingsResponse>):
        void;
    list(
        params: Params$Resource$Apps$Domainmappings$List,
        callback: BodyResponseCallback<Schema$ListDomainMappingsResponse>):
        void;
    list(callback: BodyResponseCallback<Schema$ListDomainMappingsResponse>):
        void;
    list(
        paramsOrCallback?: Params$Resource$Apps$Domainmappings$List|
        BodyResponseCallback<Schema$ListDomainMappingsResponse>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$ListDomainMappingsResponse>,
        callback?: BodyResponseCallback<Schema$ListDomainMappingsResponse>):
        void|AxiosPromise<Schema$ListDomainMappingsResponse> {
      let params =
          (paramsOrCallback || {}) as Params$Resource$Apps$Domainmappings$List;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Domainmappings$List;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/domainMappings')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId'],
        pathParams: ['appsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$ListDomainMappingsResponse>(
            parameters, callback);
      } else {
        return createAPIRequest<Schema$ListDomainMappingsResponse>(parameters);
      }
    }


    /**
     * appengine.apps.domainMappings.patch
     * @desc Updates the specified domain mapping. To map an SSL certificate to
     * a domain mapping, update certificate_id to point to an
     * AuthorizedCertificate resource. A user must be authorized to administer
     * the associated domain in order to update a DomainMapping resource.
     * @alias appengine.apps.domainMappings.patch
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. Name of the resource to update. Example: apps/myapp/domainMappings/example.com.
     * @param {string} params.domainMappingsId Part of `name`. See documentation of `appsId`.
     * @param {boolean=} params.noManagedCertificate Whether a managed certificate should be provided by App Engine. If true, a certificate ID must be manually set in the DomainMapping resource to configure SSL for this domain. If false, a managed certificate will be provisioned and a certificate ID will be automatically populated. Only applicable if ssl_settings.certificate_id is specified in the update mask.
     * @param {string=} params.updateMask Standard field mask for the set of fields to be updated.
     * @param {().DomainMapping} params.resource Request body data
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    patch(
        params?: Params$Resource$Apps$Domainmappings$Patch,
        options?: MethodOptions): AxiosPromise<Schema$Operation>;
    patch(
        params: Params$Resource$Apps$Domainmappings$Patch,
        options: MethodOptions|BodyResponseCallback<Schema$Operation>,
        callback: BodyResponseCallback<Schema$Operation>): void;
    patch(
        params: Params$Resource$Apps$Domainmappings$Patch,
        callback: BodyResponseCallback<Schema$Operation>): void;
    patch(callback: BodyResponseCallback<Schema$Operation>): void;
    patch(
        paramsOrCallback?: Params$Resource$Apps$Domainmappings$Patch|
        BodyResponseCallback<Schema$Operation>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$Operation>,
        callback?: BodyResponseCallback<Schema$Operation>):
        void|AxiosPromise<Schema$Operation> {
      let params =
          (paramsOrCallback || {}) as Params$Resource$Apps$Domainmappings$Patch;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Domainmappings$Patch;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl +
                    '/v1alpha/apps/{appsId}/domainMappings/{domainMappingsId}')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'PATCH'
            },
            options),
        params,
        requiredParams: ['appsId', 'domainMappingsId'],
        pathParams: ['appsId', 'domainMappingsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$Operation>(parameters, callback);
      } else {
        return createAPIRequest<Schema$Operation>(parameters);
      }
    }
  }

  export interface Params$Resource$Apps$Domainmappings$Create {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `parent`. Name of the parent Application resource. Example:
     * apps/myapp.
     */
    appsId?: string;
    /**
     * Whether a managed certificate should be provided by App Engine. If true,
     * a certificate ID must be manaually set in the DomainMapping resource to
     * configure SSL for this domain. If false, a managed certificate will be
     * provisioned and a certificate ID will be automatically populated.
     */
    noManagedCertificate?: boolean;
    /**
     * Whether the domain creation should override any existing mappings for
     * this domain. By default, overrides are rejected.
     */
    overrideStrategy?: string;

    /**
     * Request body metadata
     */
    requestBody?: Schema$DomainMapping;
  }
  export interface Params$Resource$Apps$Domainmappings$Delete {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. Name of the resource to delete. Example:
     * apps/myapp/domainMappings/example.com.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    domainMappingsId?: string;
  }
  export interface Params$Resource$Apps$Domainmappings$Get {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. Name of the resource requested. Example:
     * apps/myapp/domainMappings/example.com.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    domainMappingsId?: string;
  }
  export interface Params$Resource$Apps$Domainmappings$List {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `parent`. Name of the parent Application resource. Example:
     * apps/myapp.
     */
    appsId?: string;
    /**
     * Maximum results to return per page.
     */
    pageSize?: number;
    /**
     * Continuation token for fetching the next page of results.
     */
    pageToken?: string;
  }
  export interface Params$Resource$Apps$Domainmappings$Patch {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. Name of the resource to update. Example:
     * apps/myapp/domainMappings/example.com.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    domainMappingsId?: string;
    /**
     * Whether a managed certificate should be provided by App Engine. If true,
     * a certificate ID must be manually set in the DomainMapping resource to
     * configure SSL for this domain. If false, a managed certificate will be
     * provisioned and a certificate ID will be automatically populated. Only
     * applicable if ssl_settings.certificate_id is specified in the update
     * mask.
     */
    noManagedCertificate?: boolean;
    /**
     * Standard field mask for the set of fields to be updated.
     */
    updateMask?: string;

    /**
     * Request body metadata
     */
    requestBody?: Schema$DomainMapping;
  }


  export class Resource$Apps$Locations {
    root: Appengine;
    constructor(root: Appengine) {
      this.root = root;
      this.getRoot.bind(this);
    }

    getRoot() {
      return this.root;
    }


    /**
     * appengine.apps.locations.get
     * @desc Gets information about a location.
     * @alias appengine.apps.locations.get
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. Resource name for the location.
     * @param {string} params.locationsId Part of `name`. See documentation of `appsId`.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    get(params?: Params$Resource$Apps$Locations$Get,
        options?: MethodOptions): AxiosPromise<Schema$Location>;
    get(params: Params$Resource$Apps$Locations$Get,
        options: MethodOptions|BodyResponseCallback<Schema$Location>,
        callback: BodyResponseCallback<Schema$Location>): void;
    get(params: Params$Resource$Apps$Locations$Get,
        callback: BodyResponseCallback<Schema$Location>): void;
    get(callback: BodyResponseCallback<Schema$Location>): void;
    get(paramsOrCallback?: Params$Resource$Apps$Locations$Get|
        BodyResponseCallback<Schema$Location>,
        optionsOrCallback?: MethodOptions|BodyResponseCallback<Schema$Location>,
        callback?: BodyResponseCallback<Schema$Location>):
        void|AxiosPromise<Schema$Location> {
      let params =
          (paramsOrCallback || {}) as Params$Resource$Apps$Locations$Get;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Locations$Get;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/locations/{locationsId}')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId', 'locationsId'],
        pathParams: ['appsId', 'locationsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$Location>(parameters, callback);
      } else {
        return createAPIRequest<Schema$Location>(parameters);
      }
    }


    /**
     * appengine.apps.locations.list
     * @desc Lists information about the supported locations for this service.
     * @alias appengine.apps.locations.list
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. The resource that owns the locations collection, if applicable.
     * @param {string=} params.filter The standard list filter.
     * @param {integer=} params.pageSize The standard list page size.
     * @param {string=} params.pageToken The standard list page token.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    list(params?: Params$Resource$Apps$Locations$List, options?: MethodOptions):
        AxiosPromise<Schema$ListLocationsResponse>;
    list(
        params: Params$Resource$Apps$Locations$List,
        options: MethodOptions|
        BodyResponseCallback<Schema$ListLocationsResponse>,
        callback: BodyResponseCallback<Schema$ListLocationsResponse>): void;
    list(
        params: Params$Resource$Apps$Locations$List,
        callback: BodyResponseCallback<Schema$ListLocationsResponse>): void;
    list(callback: BodyResponseCallback<Schema$ListLocationsResponse>): void;
    list(
        paramsOrCallback?: Params$Resource$Apps$Locations$List|
        BodyResponseCallback<Schema$ListLocationsResponse>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$ListLocationsResponse>,
        callback?: BodyResponseCallback<Schema$ListLocationsResponse>):
        void|AxiosPromise<Schema$ListLocationsResponse> {
      let params =
          (paramsOrCallback || {}) as Params$Resource$Apps$Locations$List;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Locations$List;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/locations')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId'],
        pathParams: ['appsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$ListLocationsResponse>(parameters, callback);
      } else {
        return createAPIRequest<Schema$ListLocationsResponse>(parameters);
      }
    }
  }

  export interface Params$Resource$Apps$Locations$Get {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. Resource name for the location.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    locationsId?: string;
  }
  export interface Params$Resource$Apps$Locations$List {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. The resource that owns the locations collection, if
     * applicable.
     */
    appsId?: string;
    /**
     * The standard list filter.
     */
    filter?: string;
    /**
     * The standard list page size.
     */
    pageSize?: number;
    /**
     * The standard list page token.
     */
    pageToken?: string;
  }


  export class Resource$Apps$Operations {
    root: Appengine;
    constructor(root: Appengine) {
      this.root = root;
      this.getRoot.bind(this);
    }

    getRoot() {
      return this.root;
    }


    /**
     * appengine.apps.operations.get
     * @desc Gets the latest state of a long-running operation. Clients can use
     * this method to poll the operation result at intervals as recommended by
     * the API service.
     * @alias appengine.apps.operations.get
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. The name of the operation resource.
     * @param {string} params.operationsId Part of `name`. See documentation of `appsId`.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    get(params?: Params$Resource$Apps$Operations$Get,
        options?: MethodOptions): AxiosPromise<Schema$Operation>;
    get(params: Params$Resource$Apps$Operations$Get,
        options: MethodOptions|BodyResponseCallback<Schema$Operation>,
        callback: BodyResponseCallback<Schema$Operation>): void;
    get(params: Params$Resource$Apps$Operations$Get,
        callback: BodyResponseCallback<Schema$Operation>): void;
    get(callback: BodyResponseCallback<Schema$Operation>): void;
    get(paramsOrCallback?: Params$Resource$Apps$Operations$Get|
        BodyResponseCallback<Schema$Operation>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$Operation>,
        callback?: BodyResponseCallback<Schema$Operation>):
        void|AxiosPromise<Schema$Operation> {
      let params =
          (paramsOrCallback || {}) as Params$Resource$Apps$Operations$Get;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Operations$Get;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url:
                  (rootUrl + '/v1alpha/apps/{appsId}/operations/{operationsId}')
                      .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId', 'operationsId'],
        pathParams: ['appsId', 'operationsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$Operation>(parameters, callback);
      } else {
        return createAPIRequest<Schema$Operation>(parameters);
      }
    }


    /**
     * appengine.apps.operations.list
     * @desc Lists operations that match the specified filter in the request. If
     * the server doesn't support this method, it returns UNIMPLEMENTED.NOTE:
     * the name binding allows API services to override the binding to use
     * different resource name schemes, such as users/x/operations. To override
     * the binding, API services can add a binding such as
     * "/v1/{name=users/x}/operations" to their service configuration. For
     * backwards compatibility, the default name includes the operations
     * collection id, however overriding users must ensure the name binding is
     * the parent resource, without the operations collection id.
     * @alias appengine.apps.operations.list
     * @memberOf! ()
     *
     * @param {object} params Parameters for request
     * @param {string} params.appsId Part of `name`. The name of the operation's parent resource.
     * @param {string=} params.filter The standard list filter.
     * @param {integer=} params.pageSize The standard list page size.
     * @param {string=} params.pageToken The standard list page token.
     * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.
     * @param {callback} callback The callback that handles the response.
     * @return {object} Request object
     */
    list(
        params?: Params$Resource$Apps$Operations$List,
        options?: MethodOptions): AxiosPromise<Schema$ListOperationsResponse>;
    list(
        params: Params$Resource$Apps$Operations$List,
        options: MethodOptions|
        BodyResponseCallback<Schema$ListOperationsResponse>,
        callback: BodyResponseCallback<Schema$ListOperationsResponse>): void;
    list(
        params: Params$Resource$Apps$Operations$List,
        callback: BodyResponseCallback<Schema$ListOperationsResponse>): void;
    list(callback: BodyResponseCallback<Schema$ListOperationsResponse>): void;
    list(
        paramsOrCallback?: Params$Resource$Apps$Operations$List|
        BodyResponseCallback<Schema$ListOperationsResponse>,
        optionsOrCallback?: MethodOptions|
        BodyResponseCallback<Schema$ListOperationsResponse>,
        callback?: BodyResponseCallback<Schema$ListOperationsResponse>):
        void|AxiosPromise<Schema$ListOperationsResponse> {
      let params =
          (paramsOrCallback || {}) as Params$Resource$Apps$Operations$List;
      let options = (optionsOrCallback || {}) as MethodOptions;

      if (typeof paramsOrCallback === 'function') {
        callback = paramsOrCallback;
        params = {} as Params$Resource$Apps$Operations$List;
        options = {};
      }

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
        options = {};
      }

      const rootUrl = options.rootUrl || 'https://appengine.googleapis.com/';
      const parameters = {
        options: Object.assign(
            {
              url: (rootUrl + '/v1alpha/apps/{appsId}/operations')
                       .replace(/([^:]\/)\/+/g, '$1'),
              method: 'GET'
            },
            options),
        params,
        requiredParams: ['appsId'],
        pathParams: ['appsId'],
        context: this.getRoot()
      };
      if (callback) {
        createAPIRequest<Schema$ListOperationsResponse>(parameters, callback);
      } else {
        return createAPIRequest<Schema$ListOperationsResponse>(parameters);
      }
    }
  }

  export interface Params$Resource$Apps$Operations$Get {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. The name of the operation resource.
     */
    appsId?: string;
    /**
     * Part of `name`. See documentation of `appsId`.
     */
    operationsId?: string;
  }
  export interface Params$Resource$Apps$Operations$List {
    /**
     * Auth client or API Key for the request
     */
    auth?: string|OAuth2Client|JWT|Compute|UserRefreshClient;

    /**
     * Part of `name`. The name of the operation's parent resource.
     */
    appsId?: string;
    /**
     * The standard list filter.
     */
    filter?: string;
    /**
     * The standard list page size.
     */
    pageSize?: number;
    /**
     * The standard list page token.
     */
    pageToken?: string;
  }
}
